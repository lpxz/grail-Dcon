//PARSER_BEGIN(PNparser)//////package hk.ust.lpxz.petri.graph.GadaraSupport.parser;//import hk.ust.lpxz.petri.graph.GadaraSupport.CommGadaraFormat;//import java.io.StringReader;//import java.io.Reader;//import java.io.BufferedReader;//import java.io.File;//import java.io.FileReader;//import java.io.IOException;//import java.util.ArrayList;//import java.util.List;//import java.util.HashMap;//import java.util.HashSet;////public class PNparser {//// //   public static List list ;//    public PNparser(String s) //    {//        this((Reader)(new StringReader(s))); //        list = new  ArrayList();//    }//    //  //    public static void main(String args[])//    {//        try//        {       PNparser parser = new PNparser(new java.io.FileInputStream(args[0]));//                parser.parse();//                System.out.println(list.size());//        }//        catch(Exception e)//        {//                e.printStackTrace();//        }//    }//}//////PARSER_END(PNparser) /////**  And now, the actual parsing specifications...... *//////** Skip these characters, they are considered "white space" **///SKIP :                              //{//    " "//    | "\t"//    | "\r"//    | "\n"////}//////TOKEN: /*RESERVED TOKENS FOR UQL *///{    //    <EQUALS:  "="> //: WithinATTR//   | < ATTRSEP: ",">//   |  < DECLSEP: ";">//   |  < RBRACE: "}">//   | < LBRACE: "{">  //   | < PLACECOMMON: "PlaceCommonLocal" >//   | < PLACEENTRY: "PlaceMethodEntry">//   | < PLACEEXIT:"PlaceMethodExit">//   | < PLACERESOURCE:"PlaceResource">//   | <PLACECONTROL: "PlaceControl" >//   | < TRANSITION:"Transition">//   | < ARCLOCAL:"ArcLocal">//            | < ARCCALL:"ArcCall">//           | < ARCRETURN:"ArcReturn"> //     | < ARCFROMRESOURCE:"ArcFromResource">//       | < ARCTORESOURCE:"ArcToResource">    //           | < ARCFROMCONTROLLER:"ArcFromController">     //           | < ARCTOCONTROLLER:"ArcToController">           //   | < PETRIMETHOD:"PetriMethod">//   | < PETRICS:"PetriCS">//   | < VIOLATION:"Violation">//   | < ARROW: "->">//   | < STMTATTR: "stmt">//   | < TOKENATTR: "token">//   | < ENCLOSINGMATTR: "enclosingPM">//   | < CONTROLLABLEATTR: "controllable">//   | < OBSERVABLEATTR: "observable">//   | < WEIGHTATTR:"weight">//   |< CTREDPLACE:"ctredplace">//   |< OBSEDPLACES:"obsedplaces">//   | < METHODSIGATTR: "methodsig">//   | < ENTRYATTR: "entry">//   | < EXITATTR: "exit">//   | < PPLACEATTR:"pplace">//   | < CPLACEATTR:"cplace">//   | < RPLACEATTR:"rplace">//   | < RESOURCEATTR:"resource">//   | < PLACESATTR:"places">//   | < TRUE: "true">//   | < FALSE: "false">//   //   //}////////////TOKEN : /* the keywords and comparators - QUOTEDVALUE accounts for escaped quotes as well *///{//  //  ,"a"-"z"////   <VARNAME: (["a"-"z","A"-"Z"])+ (["0"-"9"])+ >// | < INTEGER: (["0"-"9"])+>//   //   //   ////}///////** // *  Top level// *///void parse() ://{//}//{//    whole()   <EOF>       // a query followed by optional sort//}/////**// * An expression is defined to be a queryTerm followed by zero or more// * query terms joined by either an AND or an OR.   If two query terms are joined with // * AND then both conditions must be met.  If two query terms are joined with an OR, then// * one of the two conditions must be met.  // *///void whole() ://{//}//{//   varDecList()  linkDecList()        //}////void  varDecList()://{//}//{//   ( varDec() <DECLSEP>)+//}////void linkDecList()://{//}//{//   ( linkDec() <DECLSEP>)+//}////void varDec()://{//  String vtype;//  Token tvarname;//  HashMap attriTable;//  //}//{//    vtype =vartype() tvarname=<VARNAME> <LBRACE> attriTable=attrilist()  < RBRACE>//    {//     CommGadaraFormat.seeVarDec(vtype, tvarname.image, attriTable);//    }//   //}////String vartype()://{//  Token t;//}//{//   //   t= <PLACECOMMON>//   {//   return t.image;}|//   t= < PLACEENTRY>//   {//     return t.image;//   }|//t=< PLACEEXIT>//{//return t.image;}|//t=< PLACERESOURCE>//{//return t.image;}|//t=< PLACECONTROL>//{//return t.image;}//  |t= < TRANSITION>//  {//return t.image;//  }|//  t=< ARCLOCAL>//  {//  return t.image;}|//     t=< ARCCALL>//  {//  return t.image;}|  //   t=< ARCRETURN>//  {//  return t.image;}|//   t=< ARCFROMRESOURCE>//  {//  return t.image;}|//   t=< ARCTORESOURCE>//  {//  return t.image;}|//   t=< ARCFROMCONTROLLER>//  {//  return t.image;}|//   t=< ARCTOCONTROLLER>//  {//  return t.image;}|  //  t=< PETRIMETHOD>//  {//  return t.image;}|//  t=< PETRICS>//  {//  return t.image;}|t=< VIOLATION>//  {//  return t.image;}//}////HashMap attrilist()://{//  HashMap toret;//  HashMap tmp; //}//{//    {//      toret = new HashMap();//    }//   tmp= attriDec()//   {//     toret.putAll(tmp);//   } (< ATTRSEP>tmp= attriDec()//   {//     toret.putAll(tmp);//   })*////   {//   return toret;//   }////}//////HashMap attriDec()://{//   HashMap toret = new HashMap();//   Token t1;//   Token t2;//    Token t3;//    HashSet tmpSet;//}//{//   //   //  LOOKAHEAD(3)//   t1= <STMTATTR> < EQUALS> t3=< INTEGER>//   {//      toret.put(t1.image, t3.image); return toret;//   }|// LOOKAHEAD(3)//   t1= <STMTATTR> < EQUALS>//    {//      toret.put(t1.image, "");//      return toret;//    }|//    t1= < TOKENATTR> < EQUALS> t3=< INTEGER>//    {//      toret.put(t1.image, t3.image); return toret;//    }|//   LOOKAHEAD(3) t1= < ENCLOSINGMATTR>  < EQUALS>  t3=< VARNAME>//   {//      toret.put(t1.image, t3.image); return toret;//   }|  LOOKAHEAD(3)t1=  < ENCLOSINGMATTR>  < EQUALS>//   {//  toret.put(t1.image,""); return toret;//   }|//    LOOKAHEAD(3) t1= < CONTROLLABLEATTR>    < EQUALS> t3=< TRUE>//    {//    toret.put(t1.image, t3.image); return toret;//    } |  LOOKAHEAD(3)  t1=< CONTROLLABLEATTR>    < EQUALS> t3=< FALSE>//    {// toret.put(t1.image, t3.image); return toret;//    }//  |  LOOKAHEAD(3) t1= < OBSERVABLEATTR>    < EQUALS> t3=< TRUE>//  {// toret.put(t1.image, t3.image); return toret;//  }  |   LOOKAHEAD(3)t1=< OBSERVABLEATTR>    < EQUALS> t3=< FALSE>//  {// toret.put(t1.image, t3.image); return toret;//  }//  | t1=< WEIGHTATTR>  < EQUALS>t3= < INTEGER>//  {// toret.put(t1.image, t3.image); return toret;//  } |//t1=  < METHODSIGATTR> < EQUALS> t3=< INTEGER>//  {// toret.put(t1.image, t3.image); return toret;//  }|//  t1= < ENTRYATTR>  < EQUALS> t3=< VARNAME>//  {// toret.put(t1.image, t3.image); return toret;//  }|// t1= < EXITATTR> < EQUALS> t3=< VARNAME>//  {// toret.put(t1.image, t3.image); return toret;//  } |//  t1=< PPLACEATTR> < EQUALS> t3=< VARNAME>//  {// toret.put(t1.image, t3.image); return toret;//  }|//  t1= < CPLACEATTR> < EQUALS> t3=< VARNAME>//   {// toret.put(t1.image, t3.image); return toret;//   }|//    t1 =< RPLACEATTR> < EQUALS> t3=< VARNAME>//    {// toret.put(t1.image, t3.image); return toret;//    } |//     t1= < CTREDPLACE> < EQUALS> t3=< VARNAME>//      {// toret.put(t1.image, t3.image); return toret;//      }| t1=< RESOURCEATTR>   < EQUALS> t3=< VARNAME>//      {//  toret.put(t1.image, t3.image); return toret;//      } |//       t1= < OBSEDPLACES> < EQUALS>  < LBRACE> tmpSet= varbag() < RBRACE>//       {//toret.put(t1.image, tmpSet); return toret;//       }|   //   t1= < PLACESATTR>  < EQUALS>  < LBRACE>tmpSet= varbag()  < RBRACE>//   {//toret.put(t1.image, tmpSet); return toret;//   }//    ////  //}//    //////HashSet varbag()://{//  HashSet toret;//  Token t1;//  Token t2;//}//{//  {//toret = new HashSet();//  }//  t1= < VARNAME>//  {//    toret.add(t1.image);//  } (< ATTRSEP> t2=< VARNAME>//  {//toret.add(t2.image);//  })*//  {//  return toret;//  }//}//////////void linkDec()://{Token t1;//Token t2;//Token t3;//}//{// t1= <VARNAME> <ARROW> t2=<VARNAME> < ARROW > t3=<VARNAME>// {//   CommGadaraFormat.seelinkDec(t1.image, t2.image, t3.image);// }//}//////////////List chain():////{List tmplist, list1, list2;}////{////  {////    tmplist=  new  ArrayList();////  }////     list1 =site()////     {////       tmplist.add(list1);////     }////  (<SITESEP> list2= site()////  {////        tmplist.add(list2);////  })*////  {////       return tmplist;////  }////}////////////
